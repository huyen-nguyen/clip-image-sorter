<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>wasm-vips memory leak debug</title>
    <script src="./vips/vips.js"></script>
  </head>
  <body>
    <button id="startBtn" onclick="start()">click here to start processing images</button>
    
    <script>
      let nProcessed = 0;
      
      async function start() {
        if(!window.showDirectoryPicker) return alert("Your browser does not support some modern features (specifically, File System Access API) required to use this web app. Please try updating your browser, or switching to Chrome, Edge, or Brave.");
        
        startBtn.disabled = true;
        
        let vips = await Vips();
        vips.EMBIND_AUTOMATIC_DELETELATER = false;
        
        let directoryHandle = await window.showDirectoryPicker();
        
        await recursivelyProcessImagesInDir(directoryHandle);
      }

      async function recursivelyProcessImagesInDir(dirHandle, currentPath="") {
        for await (let [name, handle] of dirHandle) {
          const {kind} = handle;
          let path = `${currentPath}/${name}`;
          if (handle.kind === 'directory') {
            await recursivelyProcessImagesInDir(handle, path);
          } else {
            let isImage = /\.(png|jpg|jpeg|webp)$/.test(path);
            if(!isImage) continue;
            
            let blob = await handle.getFile();
            let rgbData = await getRgbData(blob);
            if(nProcessed++ % 100 === 0) console.log(`${nProcessed} images processed`);
          }
        }
      }

      async function getFileHandleByPath(path) {
        let handle = directoryHandle;
        let chunks = path.split("/").slice(1);
        for(let i = 0; i < chunks.length; i++) {
          let chunk = chunks[i];
          if(i === chunks.length-1) {
            handle = await handle.getFileHandle(chunk);
          } else {
            handle = await handle.getDirectoryHandle(chunk);
          }
        }
        return handle;
      }
      
      async function getRgbData(blob) {
        let resizedBlob = await bicubicResizeAndCenterCrop(blob);
        let img = await createImageBitmap(resizedBlob);

        let canvas = new OffscreenCanvas(224, 224);
        let ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        let rgbData = [[], [], []]; // [r, g, b]
        // remove alpha and put into correct shape:
        let d = imageData.data;
        for(let i = 0; i < d.length; i += 4) { 
          let x = (i/4) % canvas.width;
          let y = Math.floor((i/4) / canvas.width)
          if(!rgbData[0][y]) rgbData[0][y] = [];
          if(!rgbData[1][y]) rgbData[1][y] = [];
          if(!rgbData[2][y]) rgbData[2][y] = [];
          rgbData[0][y][x] = d[i+0]/255;
          rgbData[1][y][x] = d[i+1]/255;
          rgbData[2][y][x] = d[i+2]/255;
          // From CLIP repo: Normalize(mean=(0.48145466, 0.4578275, 0.40821073), std=(0.26862954, 0.26130258, 0.27577711))
          rgbData[0][y][x] = (rgbData[0][y][x] - 0.48145466) / 0.26862954;
          rgbData[1][y][x] = (rgbData[1][y][x] - 0.4578275) / 0.26130258;
          rgbData[2][y][x] = (rgbData[2][y][x] - 0.40821073) / 0.27577711;
        }
        rgbData = Float32Array.from(rgbData.flat().flat());
        return rgbData;
      }
      
      async function bicubicResizeAndCenterCrop(blob) {
        let im1 = vips.Image.newFromBuffer(await blob.arrayBuffer());

        // Resize so smallest side is 224px:
        let resizeFactor = 1;
        if (im1.width > im1.height) {
            resizeFactor = 224 / im1.height;
        } else {
            resizeFactor = 224 / im1.width;
        }

        let im2 = im1.resize(resizeFactor, { kernel: vips.Kernel.cubic });

        // crop to 224x224:
        let left = (im2.width - 224) / 2;
        let top = (im2.height - 224) / 2;
        let im3 = im2.crop(left, top, 224, 224)

        let outBuffer = new Uint8Array(im3.writeToBuffer('.png'));
        im1.delete(), im2.delete(), im3.delete();
        return new Blob([outBuffer], { type: 'image/png' });
      }

      function sleep(ms) {
        return new Promise(r => setTimeout(r, ms));
      }
    </script>
  </body>
</html>
